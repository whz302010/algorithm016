学习笔记

本周主要学习了哈希表、树、堆、图

**1.HashMap**
HashMap在实际工作和算法中是经常使用到的，又称散列表，功能上与HashTable基本一致，只不过HashMap是线程不安全的，
且支持Null值和Null键。算法题目中如果需要记录具有对应关系的数据通常都可以使用HashMap,例如：字母异位（存储字母与次数）
另外，contains方法可以方便地查询key是否存在，例如：两数之和（查询集合中是否存在target值）

**2.树**
树的插入、删除、搜索时间复杂度均为O(logn)
常见的树有：二叉搜索树、平衡树
   二叉搜索树：指一颗空树或具有以下性质的二叉树
     1.左子树上所有节点的值均小于根节点
     2.右子数上所有节点的值均大于根节点
     3.以此类推，左右子数也分别为二叉搜索树
     所以：二叉搜索树的中序遍历是升序遍历
     删除根节点方法：将刚刚大于根节点的节点替换根节点

**3.堆（heap)**
堆：可以迅速找到最大值或最小值的数据结构
大顶堆：根节点最大的堆
小顶堆：根节点最小的堆
常见的堆：二叉堆（简单，效率低）、斐波那契堆
Java中PriorityQueue底层使用堆实现，其默认是最小堆。
相关算法题目有：数组中最高频k个元素

**4.图(Graph)**
图：图与树区别就是图之间相互连接可以连成环路，图可以看做是特殊的树
图由点（Vertex)和边(Edge)组成
点（Vertex)：
   1.度（出入点的边数）---->  入度、出度
   2.点与点之间：连通与否
边(Edge)：
   1.有向和无向（无向即是双向）
   2.权重（边长）
   
                                     **HashMap小总结**
 HashMap底层使用数组+链表，使用数组存储Entry结构，使用数组所以查询时间复杂度为O(1),插入删除时间复杂度为O(n)
 当发生hash碰撞时，使用链表存储相同hash键的值
 **注意：JDK1.8中HashMap采用数组+链表+红黑树实现。** 
 当链表长度超过阈值（8）时，将链表转换为红黑树。在性能上进一步得到提升。
 
 1.HashMap与HashTable区别：
    1.HashMap线程不安全，非syncronized
    2.HashMap支持Null值和Null键，其中键不允许重复，且是无序的
    
 2.HashMap初识容量是16，HashTable初始容量是11，两者的填充因子都是0.75；
 HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1
 扩容性能消耗较大，最好可以预算初始化具体数值
 
 3.hash值计算
 HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取摸
 
 4.加载因子
 加载因子是表示Hash表中元素的填满的程度。
 加载因子越大,填满的元素越多,空间利用率越高，但冲突的机会加大了。
 反之,加载因子越小,填满的元素越少,冲突的机会减小,但空间浪费多了。
 冲突的机会越大,则查找的成本越高。反之,查找的成本越小


     